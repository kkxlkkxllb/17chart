{
  "name": "hem",
  "version": "0.3.4",
  "description": "stiches CommonJS, and ties up other lose ends of web-app development.",
  "keywords": [
    "spine",
    "commonsJS",
    "coffeescript",
    "stylus",
    "jade",
    "eco",
    "testacular",
    "jasmine"
  ],
  "contributors": [
    {
      "name": "maccman"
    },
    {
      "name": "aeischeid"
    },
    {
      "name": "cengebretson"
    }
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/17up/hem/blob/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/17up/hem.git"
  },
  "engine": [
    "node >=0.6.0"
  ],
  "main": "./lib/hem.js",
  "bin": {
    "hem": "./bin/hem"
  },
  "preferGlobal": true,
  "dependencies": {
    "eco": "1.1.0-rc-3",
    "fast-detective": "~0.0.2",
    "optimist": "~0.3.0",
    "stylus": ">=0.32.0",
    "coffee-script": ">=1.6.0",
    "watch": "~0.5.0",
    "connect": "~2.6.0",
    "http-proxy": "~0.8.2",
    "karma": ">=0.8.0",
    "jade": ">=0.28.2",
    "file": ">=0.2.1",
    "uglify-js": "~2.4.0"
  },
  "readme": "#Introduction\n\nHem is a project for compiling CommonJS modules when building JavaScript web applications. You can think of Hem as [Bundler](http://gembundler.com/) for Node, or [Stitch](https://github.com/sstephenson/stitch) on steroids. Or it is kind of like [Yeoman](http://yeoman.io/), tailored specifically for spine.js\n\nThis is rather awesome, as it means you don't need to faff around with coping around JavaScript files. jQuery can be a npm dependency, so can jQueryUI and all your custom components. Hem will resolve dependencies dynamically, bundling them together into one file to be served up. Upon deployment, you can serialize your application to disk and serve it statically.\n\nHem was primarily designed for developing Spine.js based Single Page Web Applications (SPA's), so a major role it fills is to tie up some of the other lose ends of a frontend development project - things like running tests, precompiling code, and preparing it for deployment. It can even help out in the API connection stuff if your app needs that.\n\n#Installation\n\n    npm install -g hem\n\nor\n\n    npm install -g git://github.com/spine/hem.git\n\nor ...fun trick.\n\n    hem install -g hem \n    git clone https://github.com/spine/hem.git\n    cd hem\n    npm link\n\nthis last approach is great if you want to customize hem for your own use, (...or for developing npm packages in general). Just fork and use you own path!\n\n##Dependencies\n\nHem has two types of dependency resolutions: Node modules and Stitch modules.\n\nNode modules: Hem will recursively resolve any external Node modules your code references. This means that Spine, jQuery etc, can all be external Node modules - you don't have lots of libraries floating around your application. This also has the advantage of explicit versioning; you'll have much more control over external libraries.\n\nStitch modules: Hem will bundle up your whole application (without any static dependency analysis), automatically converting CoffeeScript (.coffee) and jQuery template (.tmpl) files. Hem doesn't use static analysis of your application to determine dependencies, as that's often not-viable considering the amount of dynamically loaded dependencies most applications use.\n\nIn a nutshell, Hem will make sure your application and all its dependencies are wrapped up in a single file, ready to be served to web browsers.\n\n##CommonJS\n\nCommonJS modules are at the core of Hem, and are the format Hem aspects every module to adhere to. As well as ensuring your code is encapsulated and modular, CommonJS modules give you dependency management, scope isolation, and namespacing. They should be used in any JavaScript application that spans more than a few files.\n\nTo find out more about why CommonJS modules are a great solution to JavaScript dependency management, see the CommonJS guide\n\nIt's not that AMD pattern is bad by the way, just not the way hem went for now.\n\n###The Format\n\nThe format is remarkably straightforward, but is something you'll have to adhere to in every file to make it work. CommonJS uses explicit exporting; so to expose a property inside a module to other modules, you'll need to do something like this:\n\nIn app/controllers/users.coffee:\n\n    class Users extends Spine.Controller\n\nExplicitly export the Users object\n\n    module.exports = Users\n\nThe format mandates that a module object will be available in every module. However, if you're targeting both the CommonJS format, and a normal environment, you can do a conditional export, checking that the module object exists.\n\n    module?.exports = Users\n\n###Requiring modules\n\nRequiring other modules is just as straightforward; just use the require() function.\n\n    Users = require(\"controllers/users\")\n\nIn Hem apps, all module paths are relative to the app folder - so don't require files relative to the specific module.\nCSS\n\n##Styling your app\n\nHem will also bundle up all your application's CSS into one file, ready to serve up to clients. CSS encapsulation and modularity is just as important as JavaScript de-coupling (and can get as equally messy if it's not done right); Hem goes some way to help you with this. To compile CSS, Hem uses an excellent library called Stylus. Stylus is mostly a superset of CSS, and the normal CSS syntax will work just fine if that's all you want.\n\nHowever the awesome part of Stylus is the extra syntactical sugar it brings to CSS. Features like optional braces and colons, mixins, variables and significant whitespace all vastly improve your application's CSS, and decreases the amount of typing necessary. In a nutshell, Stylus is to CSS as CoffeeScript is to JavaScript.\n\nStylus files are indicated by the .styl extension, and are automatically compiled down to CSS by Hem. This all happens in the background, so you don't need to worry about it.\n\nAlso in the pipeline is the ability to bundle up CSS from Node modules.\n\n##slug.json\n\nHem has some good defaults (convention over configuration), but sometimes you'll need to change them, especially when adding libraries and dependencies.\n\nFor configuration, Hem uses a slug.json file, located in the root of your application. Hem expects a certain directory structure. A main JavaScript/CoffeeScript file under app/index, a main CSS/Stylus file under css/index and a public directory to serve static assets from. If you're using Spine.app, these will all be generated for you.\n\nHem also allows you to specify static JavaScript libraries to include, under the \"libs\" option:\n\n    {\n      \"libs\": [\n        \"./lib/other.js\"\n      ]\n    }\n\nThese will be included before the rest of your JavaScript, and without being wrapped in the CommonJS module transport format. In addition, Hem lets you specify an array of npm/Node dependencies, to be included in your application. For example, in a default generated Spine.app slug.json file, you'll find the following dependencies:\n\n    {\n      \"dependencies\": [\n        \"es5-shimify\",\n        \"json2ify\",\n        \"jqueryify\",\n        \"jquery.tmpl\",\n        \"spine\"\n      ]\n    }\n\nThese dependencies will be statically analyzed, to recursively resolve additional dependencies, and then wrapped in the CommonJS module format, being served up with the rest of your application's JavaScript. In other words, you don't have to have jquery.js, spine.js and json2.js floating around inside your application, they can be Node modules, installed through npm.\n\n##Usage\n\nOk, so now we've looked at how to configure Hem, let's actually use it in an application. As I mentioned earlier, this step is much easier with an application previously generated by Spine.app, and I advise you go down this route if you're unfamiliar with Hem.\n\nNow, we can start a development server, which will dynamically build our application every request, using the server command:\n\n    hem server\n\nBy default, your spine application is served at http://localhost:9294. \nYou can configure the host and port from command line or as settings in your package.json\n\n    hem server -p 9295\n    \nWould result in your application being served at http://localhost:9295/\n\nIf there's an index.html file under public, it'll be served up. Likewise, any calls to /application.js and /application.css will return the relevant JavaScript and CSS.\n\nFor the sake of avoiding cross domain issues in development environments when your spine app is utilizing an ajax api there is a optional proxy server built into hem.\nAs of Hem 0.3 including a 'routes' block in your slug.json configures that:\n    \n    \"server\": {\n        \"port\"  : 9294\n    },\n    \"routes\": [\n        { \"/myApiApp/mySpineApp\"        : \"./public\" },\n        { \"/myApiApp/mySpineApp/test\"   : \"./test/public\" },\n        { \"/myApiApp\"                   : { \"host\": \"127.0.0.1\", \"port\": 8080, \"hostPath\": \"/myApiApp\", \"patchRedirect\": true } }\n    ],\n    \"packages\": {\n        \"sampleApp\": {\n          \"libs\"    : [\"lib/runtime.js\"],\n          \"modules\" : [\n              \"es5-shimify\",\n              \"json2ify\",\n              \"jqueryify\",\n              \"spine\",\n              \"spine/lib/local\",\n              \"spine/lib/ajax\",\n              \"spine/lib/route\",\n              \"spine/lib/manager\"\n          ],\n          \"paths\"  : [\"./app\"],\n          \"target\" : \"./public/application.js\",\n          \"jsAfter\": \"jade.rethrow = function rethrow(err, filename, lineno){ throw err; } \"\n        },\n    \"css\": {\n      \"paths\"  : \"./css\",\n      \"target\" : \"./public/application.css\"\n    },\n    \"test\": {\n      \"identifier\" : \"specs\",\n      \"jsAfter\"    : \"require('lib/setup'); for (var key in specs.modules) specs(key);\",\n      \"paths\"      : [\"./test/specs\"],\n      \"target\"     : \"./test/public/specs.js\"\n    }\n  }\n\nnow http://127.0.0.1:9294/myApiApp/mySpineApp/ will return the spine app.\n\nand http://127.0.0.1:9294/myApiApp/ will return your API App\n\nso relative links like @url = \"../api/album/\" from inside your spine app models can resolve against your apiapp without issue\n\nWhen you're ready to deploy, you should build your application, serializing it to disk.\n\n    hem build\n\nThis will write application.js and application.css and specs.js to the file system. You can then commit it with version control and have your server can statically serve your application, without having to use Node, or have any npm dependencies installed.\n\n**TODO**: hem build should have an option to version the js/css it producess and replace the references in index.html as well\n\n###Views\n\nCurrently Hem supports three template options out of the box \n* Straigt HTML - stringifed html... that you can render... \n* [Eco](https://github.com/sstephenson/eco) - erb like syntax, like ejs, but with coffeeScript. Nice, but seems to be a somewhat abandoned project\n* [Jade](https://github.com/visionmedia/jade) - haml like syntax with optional coffeescript filter\n  * to use jade templates you must include jades [runtime.js](https://github.com/visionmedia/jade/blob/master/runtime.js) as a lib in your spine projects slug.json\n      \"libs\": [\"lib/runtime.js\"],\n      \n###Testing\n\n[Karma(formally Testacular)](http://karma-runner.github.io/0.8/index.html) is a neat little tool that we leverage with hem. \n\n    hem test\n\nWill run tests in a spine projects test directory. Tests can be written in CoffeeScript! \n\n    hem watch -t\n\nWill run tests as test files are updated. Karma makes it smart. Only previously failing tests run. If there were no previously failing tests all will run. \nDefault is to run tests in a new Chrome window. Firefox, Phantom or some others can be used as well.\n\n    hem server\n\nwill watch and compile jasmine tests, but you will have to go to localhost:9294/test (or whereever you configured hem to run...) and manually trigger page tests to run.\n\n#TODO\n\n* Better document Karma usage instructions.\n* Make template and CSS pre-processor choices configurable  \n* This would be cool -> integrate with live-reload for changes. We should be able to inject [live-reload](https://github.com/livereload/livereload-js) while in server mode and then run the livereload-server inside hem or could strata handle the incoming requests? Looks like simple json requests. Would we need an option for the browser to regain its focus? Another option is instead of injecting the script into the page is to use the live reload plugin.\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/17up/hem/issues"
  },
  "_id": "hem@0.3.4",
  "dist": {
    "shasum": "fd28d80cd1f60063f80d6c73bf09cab72e731cdf"
  },
  "_resolved": "git://github.com/17up/hem.git#cccb6edb60caffddcee479f744aaec35413c3362",
  "_from": "git://github.com/17up/hem.git"
}
